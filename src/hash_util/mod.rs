//! Hash utilities

use {
    crate::common::MAX_MEMORY_SIZE,
    std::{cmp::min, mem::size_of},
};

// Copyright 2020 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
// except in compliance with the License.  You may obtain a copy of the License at
//     https://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software distributed under the
// License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
// either express or implied.  See the License for the specific language governing permissions
// and limitations under the License.

/// Gets the hash value by Murmur hashing.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `seed`: The seed value.
///
/// # Returns
/// The hash value.
pub fn hash_murmur(mut buf: &[u8], seed: u64) -> u64 {
    assert!(buf.len() <= MAX_MEMORY_SIZE as usize);
    const MUL: u64 = 0xc6a4a7935bd1e995;
    const RTT: u32 = 47;
    let mut hash = seed ^ ((buf.len() as u64).wrapping_mul(MUL));

    while buf.len() >= size_of::<u64>() {
        let mut num = u64::from_le_bytes(buf[..size_of::<u64>()].try_into().unwrap());

        num = num.wrapping_mul(MUL);
        num ^= num.wrapping_shr(RTT);
        num = num.wrapping_mul(MUL);
        hash = hash.wrapping_mul(MUL);
        hash ^= num;

        buf = &buf[size_of::<u64>()..];
    }

    if buf.len() == 7 {
        hash ^= (buf[6] as u64) << 48;
    }

    if buf.len() >= 6 {
        hash ^= (buf[5] as u64) << 40;
    }

    if buf.len() >= 5 {
        hash ^= (buf[4] as u64) << 32;
    }

    if buf.len() >= 4 {
        hash ^= (buf[3] as u64) << 24;
    }

    if buf.len() >= 3 {
        hash ^= (buf[2] as u64) << 16;
    }

    if buf.len() >= 2 {
        hash ^= (buf[1] as u64) << 8;
    }

    #[allow(clippy::len_zero)]
    if buf.len() >= 1 {
        hash ^= buf[0] as u64;
        hash = hash.wrapping_mul(MUL);
    }

    hash ^= hash.wrapping_shr(RTT);
    hash = hash.wrapping_mul(MUL);
    hash ^= hash.wrapping_shr(RTT);
    hash
}

/// Gets the hash value by FNV hashing.
///
/// # Arguments
/// * `buf` The source buffer.
///
/// # Returns
/// The hash value.
pub fn hash_fnv(buf: &[u8]) -> u64 {
    assert!(buf.len() <= MAX_MEMORY_SIZE as usize);
    let mut hash: u64 = 14695981039346656037;

    for b in buf {
        hash = (hash ^ *b as u64).wrapping_mul(109951162811);
    }

    hash
}

/// Gets the hash value by Checksum-6, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 0 for the frist call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_checksum6_continuous(mut buf: &[u8], _finish: bool, mut seed: u32) -> u32 {
    assert!(buf.len() <= MAX_MEMORY_SIZE as usize);
    const MODULO: u32 = 61;
    const BATCH_CAP: usize = 1 << 23;

    while !buf.is_empty() {
        let batch_size = min(BATCH_CAP, buf.len());
        for b in &buf[..batch_size] {
            seed += *b as u32;
        }

        seed %= MODULO;
        buf = &buf[batch_size..];
    }

    seed
}

/// Gets the hash value by Checksum-6.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
#[inline]
pub fn hash_checksum6(buf: &[u8]) -> u32 {
    hash_checksum6_continuous(buf, true, 0)
}

/// Gets the hash value by Checksum-6.
#[inline]
pub fn hash_checksum6_pair(first_buf: &[u8], second_buf: &[u8], mut seed: u32) -> u32 {
    const MODULO: u32 = 61;
    const BATCH_CAP: usize = 1 << 23;

    let first_size = first_buf.len();
    let second_size = second_buf.len();

    if first_size + second_size < BATCH_CAP {
        for c in first_buf {
            seed += *c as u32;
        }

        for c in second_buf {
            seed += *c as u32;
        }

        seed % MODULO
    } else {
        hash_checksum6_continuous(second_buf, true, hash_checksum6_continuous(first_buf, false, seed))
    }
}

/// Gets the hash value by checksum-8, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 0 for the frist call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_checksum8_continuous(mut buf: &[u8], _finish: bool, mut seed: u32) -> u32 {
    assert!(buf.len() <= MAX_MEMORY_SIZE as usize);
    const MODULO: u32 = 251;
    const BATCH_CAP: usize = 1 << 23;

    while !buf.is_empty() {
        let batch_size = min(BATCH_CAP, buf.len());

        for b in &buf[..batch_size] {
            seed = (seed + *b as u32) % MODULO;
        }

        seed %= MODULO;
        buf = &buf[batch_size..];
    }

    seed
}

/// Gets the hash value by checksum-8.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
#[inline]
pub fn hash_checksum8(buf: &[u8]) -> u32 {
    hash_checksum8_continuous(buf, true, 0)
}

/// Gets the hash value by Checksum-8.
#[inline]
pub fn hash_checksum8_pair(first_buf: &[u8], second_buf: &[u8], mut seed: u32) -> u32 {
    const MODULO: u32 = 251;
    const BATCH_CAP: usize = 1 << 23;

    let first_size = first_buf.len();
    let second_size = second_buf.len();

    if first_size + second_size < BATCH_CAP {
        for c in first_buf {
            seed += *c as u32;
        }

        for c in second_buf {
            seed += *c as u32;
        }

        seed % MODULO
    } else {
        hash_checksum8_continuous(second_buf, true, hash_checksum8_continuous(first_buf, false, seed))
    }
}

/// Gets the hash value by Adler-6, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 1 for the frist call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_adler6_continuous(mut buf: &[u8], _finish: bool, mut seed: u32) -> u32 {
    assert!(buf.len() <= MAX_MEMORY_SIZE as usize);
    const MODULO: u32 = 7;
    const BATCH_CAP: usize = 4096;

    let mut sum = seed >> 3;
    seed &= 0x7;

    while !buf.is_empty() {
        let batch_size = min(BATCH_CAP, buf.len());

        for b in &buf[..batch_size] {
            seed += *b as u32;
            sum += seed;
        }

        seed %= MODULO;
        sum %= MODULO;
        buf = &buf[batch_size..];
    }

    (sum << 3) | seed
}

/// Gets the hash value by Adler-6.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
#[inline]
pub fn hash_adler6(buf: &[u8]) -> u32 {
    hash_adler6_continuous(buf, true, 1)
}

/// Gets the hash value by adler-8, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 1 for the frist call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_adler8_continuous(mut buf: &[u8], _finish: bool, mut seed: u32) -> u32 {
    assert!(buf.len() <= MAX_MEMORY_SIZE as usize);
    const MODULO: u32 = 13;
    const BATCH_CAP: usize = 4096;

    let mut sum = seed >> 4;
    seed &= 0xf;

    while !buf.is_empty() {
        let batch_size = min(BATCH_CAP, buf.len());

        for b in &buf[..batch_size] {
            seed += *b as u32;
            sum += seed;
        }

        seed %= MODULO;
        sum %= MODULO;
        buf = &buf[batch_size..];
    }

    (sum << 4) | seed
}

/// Gets the hash value by adler-8.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
#[inline]
pub fn hash_adler8(buf: &[u8]) -> u32 {
    hash_adler8_continuous(buf, true, 1)
}

/// Gets the hash value by Adler-16, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 1 for the frist call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_adler16_continuous(mut buf: &[u8], _finish: bool, mut seed: u32) -> u32 {
    assert!(buf.len() <= MAX_MEMORY_SIZE as usize);
    const MODULO: u32 = 251;
    const BATCH_CAP: usize = 4096;

    let mut sum = seed >> 8;
    seed &= 0xFF;

    while !buf.is_empty() {
        let batch_size = min(BATCH_CAP, buf.len());

        for b in &buf[..batch_size] {
            seed += *b as u32;
            sum += seed;
        }

        seed %= MODULO;
        sum %= MODULO;
        buf = &buf[batch_size..];
    }

    (sum << 8) | seed
}

/// Gets the hash value by Adler-16.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
#[inline]
pub fn hash_adler16(buf: &[u8]) -> u32 {
    hash_adler16_continuous(buf, true, 1)
}

/// Gets the hash value by Adler-32, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 1 for the frist call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_adler32_continuous(mut buf: &[u8], _finish: bool, mut seed: u32) -> u32 {
    assert!(buf.len() <= MAX_MEMORY_SIZE as usize);
    const MODULO: u32 = 65521;
    const BATCH_CAP: usize = 4096;

    let mut sum = seed >> 16;
    seed &= 0xFFFF;

    while !buf.is_empty() {
        let batch_size = min(BATCH_CAP, buf.len());

        for b in &buf[..batch_size] {
            seed += *b as u32;
            sum += seed;
        }

        seed %= MODULO;
        sum %= MODULO;
        buf = &buf[batch_size..];
    }

    (sum << 16) | seed
}

/// Gets the hash value by Adler-32.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
#[inline]
pub fn hash_adler32(buf: &[u8]) -> u32 {
    hash_adler32_continuous(buf, true, 1)
}

/// Gets the hash value by CRC-4, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 0 for the frist call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_crc4_continuous(mut buf: &[u8], _finish: bool, seed: u32) -> u32 {
    assert!(buf.len() <= MAX_MEMORY_SIZE as usize);

    const TABLE0: [u32; 256] = [
        0, 7, 14, 9, 5, 2, 11, 12, 10, 13, 4, 3, 15, 8, 1, 6, 13, 10, 3, 4, 8, 15, 6, 1, 7, 0, 9, 14, 2, 5, 12, 11, 3,
        4, 13, 10, 6, 1, 8, 15, 9, 14, 7, 0, 12, 11, 2, 5, 14, 9, 0, 7, 11, 12, 5, 2, 4, 3, 10, 13, 1, 6, 15, 8, 6, 1,
        8, 15, 3, 4, 13, 10, 12, 11, 2, 5, 9, 14, 7, 0, 11, 12, 5, 2, 14, 9, 0, 7, 1, 6, 15, 8, 4, 3, 10, 13, 5, 2, 11,
        12, 0, 7, 14, 9, 15, 8, 1, 6, 10, 13, 4, 3, 8, 15, 6, 1, 13, 10, 3, 4, 2, 5, 12, 11, 7, 0, 9, 14, 12, 11, 2, 5,
        9, 14, 7, 0, 6, 1, 8, 15, 3, 4, 13, 10, 1, 6, 15, 8, 4, 3, 10, 13, 11, 12, 5, 2, 14, 9, 0, 7, 15, 8, 1, 6, 10,
        13, 4, 3, 5, 2, 11, 12, 0, 7, 14, 9, 2, 5, 12, 11, 7, 0, 9, 14, 8, 15, 6, 1, 13, 10, 3, 4, 10, 13, 4, 3, 15, 8,
        1, 6, 0, 7, 14, 9, 5, 2, 11, 12, 7, 0, 9, 14, 2, 5, 12, 11, 13, 10, 3, 4, 8, 15, 6, 1, 9, 14, 7, 0, 12, 11, 2,
        5, 3, 4, 13, 10, 6, 1, 8, 15, 4, 3, 10, 13, 1, 6, 15, 8, 14, 9, 0, 7, 11, 12, 5, 2,
    ];
    const TABLE1: [u32; 256] = [
        0, 12, 1, 13, 2, 14, 3, 15, 4, 8, 5, 9, 6, 10, 7, 11, 8, 4, 9, 5, 10, 6, 11, 7, 12, 0, 13, 1, 14, 2, 15, 3, 9,
        5, 8, 4, 11, 7, 10, 6, 13, 1, 12, 0, 15, 3, 14, 2, 1, 13, 0, 12, 3, 15, 2, 14, 5, 9, 4, 8, 7, 11, 6, 10, 11, 7,
        10, 6, 9, 5, 8, 4, 15, 3, 14, 2, 13, 1, 12, 0, 3, 15, 2, 14, 1, 13, 0, 12, 7, 11, 6, 10, 5, 9, 4, 8, 2, 14, 3,
        15, 0, 12, 1, 13, 6, 10, 7, 11, 4, 8, 5, 9, 10, 6, 11, 7, 8, 4, 9, 5, 14, 2, 15, 3, 12, 0, 13, 1, 15, 3, 14, 2,
        13, 1, 12, 0, 11, 7, 10, 6, 9, 5, 8, 4, 7, 11, 6, 10, 5, 9, 4, 8, 3, 15, 2, 14, 1, 13, 0, 12, 6, 10, 7, 11, 4,
        8, 5, 9, 2, 14, 3, 15, 0, 12, 1, 13, 14, 2, 15, 3, 12, 0, 13, 1, 10, 6, 11, 7, 8, 4, 9, 5, 4, 8, 5, 9, 6, 10,
        7, 11, 0, 12, 1, 13, 2, 14, 3, 15, 12, 0, 13, 1, 14, 2, 15, 3, 8, 4, 9, 5, 10, 6, 11, 7, 13, 1, 12, 0, 15, 3,
        14, 2, 9, 5, 8, 4, 11, 7, 10, 6, 5, 9, 4, 8, 7, 11, 6, 10, 1, 13, 0, 12, 3, 15, 2, 14,
    ];
    const TABLE2: [u32; 256] = [
        0, 15, 7, 8, 14, 1, 9, 6, 5, 10, 2, 13, 11, 4, 12, 3, 10, 5, 13, 2, 4, 11, 3, 12, 15, 0, 8, 7, 1, 14, 6, 9, 13,
        2, 10, 5, 3, 12, 4, 11, 8, 7, 15, 0, 6, 9, 1, 14, 7, 8, 0, 15, 9, 6, 14, 1, 2, 13, 5, 10, 12, 3, 11, 4, 3, 12,
        4, 11, 13, 2, 10, 5, 6, 9, 1, 14, 8, 7, 15, 0, 9, 6, 14, 1, 7, 8, 0, 15, 12, 3, 11, 4, 2, 13, 5, 10, 14, 1, 9,
        6, 0, 15, 7, 8, 11, 4, 12, 3, 5, 10, 2, 13, 4, 11, 3, 12, 10, 5, 13, 2, 1, 14, 6, 9, 15, 0, 8, 7, 6, 9, 1, 14,
        8, 7, 15, 0, 3, 12, 4, 11, 13, 2, 10, 5, 12, 3, 11, 4, 2, 13, 5, 10, 9, 6, 14, 1, 7, 8, 0, 15, 11, 4, 12, 3, 5,
        10, 2, 13, 14, 1, 9, 6, 0, 15, 7, 8, 1, 14, 6, 9, 15, 0, 8, 7, 4, 11, 3, 12, 10, 5, 13, 2, 5, 10, 2, 13, 11, 4,
        12, 3, 0, 15, 7, 8, 14, 1, 9, 6, 15, 0, 8, 7, 1, 14, 6, 9, 10, 5, 13, 2, 4, 11, 3, 12, 8, 7, 15, 0, 6, 9, 1,
        14, 13, 2, 10, 5, 3, 12, 4, 11, 2, 13, 5, 10, 12, 3, 11, 4, 7, 8, 0, 15, 9, 6, 14, 1,
    ];
    const TABLE3: [u32; 256] = [
        0, 6, 12, 10, 1, 7, 13, 11, 2, 4, 14, 8, 3, 5, 15, 9, 4, 2, 8, 14, 5, 3, 9, 15, 6, 0, 10, 12, 7, 1, 11, 13, 8,
        14, 4, 2, 9, 15, 5, 3, 10, 12, 6, 0, 11, 13, 7, 1, 12, 10, 0, 6, 13, 11, 1, 7, 14, 8, 2, 4, 15, 9, 3, 5, 9, 15,
        5, 3, 8, 14, 4, 2, 11, 13, 7, 1, 10, 12, 6, 0, 13, 11, 1, 7, 12, 10, 0, 6, 15, 9, 3, 5, 14, 8, 2, 4, 1, 7, 13,
        11, 0, 6, 12, 10, 3, 5, 15, 9, 2, 4, 14, 8, 5, 3, 9, 15, 4, 2, 8, 14, 7, 1, 11, 13, 6, 0, 10, 12, 11, 13, 7, 1,
        10, 12, 6, 0, 9, 15, 5, 3, 8, 14, 4, 2, 15, 9, 3, 5, 14, 8, 2, 4, 13, 11, 1, 7, 12, 10, 0, 6, 3, 5, 15, 9, 2,
        4, 14, 8, 1, 7, 13, 11, 0, 6, 12, 10, 7, 1, 11, 13, 6, 0, 10, 12, 5, 3, 9, 15, 4, 2, 8, 14, 2, 4, 14, 8, 3, 5,
        15, 9, 0, 6, 12, 10, 1, 7, 13, 11, 6, 0, 10, 12, 7, 1, 11, 13, 4, 2, 8, 14, 5, 3, 9, 15, 10, 12, 6, 0, 11, 13,
        7, 1, 8, 14, 4, 2, 9, 15, 5, 3, 14, 8, 2, 4, 15, 9, 3, 5, 12, 10, 0, 6, 13, 11, 1, 7,
    ];

    let mut crc = seed;

    while buf.len() >= 4 {
        crc ^= u32::from_le_bytes(buf[..4].try_into().unwrap());
        crc = TABLE3[(crc & 0xFF) as usize]
            ^ TABLE2[((crc >> 8) & 0xFF) as usize]
            ^ TABLE1[((crc >> 16) & 0xFF) as usize]
            ^ TABLE0[(crc >> 24) as usize];
        buf = &buf[4..];
    }

    for b in buf {
        crc = (crc >> 8) ^ TABLE0[((crc & 0xFF) as u8 ^ *b) as usize];
    }

    crc
}

/// Gets the hash value by CRC-4.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
pub fn hash_crc4(buf: &[u8]) -> u32 {
    hash_crc4_continuous(buf, true, 0)
}

/// Gets the hash value by CRC-8, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 0 for the frist call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_crc8_continuous(mut buf: &[u8], _finish: bool, seed: u32) -> u32 {
    const TABLE0: [u32; 256] = [
        0, 7, 14, 9, 28, 27, 18, 21, 56, 63, 54, 49, 36, 35, 42, 45, 112, 119, 126, 121, 108, 107, 98, 101, 72, 79, 70,
        65, 84, 83, 90, 93, 224, 231, 238, 233, 252, 251, 242, 245, 216, 223, 214, 209, 196, 195, 202, 205, 144, 151,
        158, 153, 140, 139, 130, 133, 168, 175, 166, 161, 180, 179, 186, 189, 199, 192, 201, 206, 219, 220, 213, 210,
        255, 248, 241, 246, 227, 228, 237, 234, 183, 176, 185, 190, 171, 172, 165, 162, 143, 136, 129, 134, 147, 148,
        157, 154, 39, 32, 41, 46, 59, 60, 53, 50, 31, 24, 17, 22, 3, 4, 13, 10, 87, 80, 89, 94, 75, 76, 69, 66, 111,
        104, 97, 102, 115, 116, 125, 122, 137, 142, 135, 128, 149, 146, 155, 156, 177, 182, 191, 184, 173, 170, 163,
        164, 249, 254, 247, 240, 229, 226, 235, 236, 193, 198, 207, 200, 221, 218, 211, 212, 105, 110, 103, 96, 117,
        114, 123, 124, 81, 86, 95, 88, 77, 74, 67, 68, 25, 30, 23, 16, 5, 2, 11, 12, 33, 38, 47, 40, 61, 58, 51, 52,
        78, 73, 64, 71, 82, 85, 92, 91, 118, 113, 120, 127, 106, 109, 100, 99, 62, 57, 48, 55, 34, 37, 44, 43, 6, 1, 8,
        15, 26, 29, 20, 19, 174, 169, 160, 167, 178, 181, 188, 187, 150, 145, 152, 159, 138, 141, 132, 131, 222, 217,
        208, 215, 194, 197, 204, 203, 230, 225, 232, 239, 250, 253, 244, 243,
    ];
    const TABLE1: [u32; 256] = [
        0, 21, 42, 63, 84, 65, 126, 107, 168, 189, 130, 151, 252, 233, 214, 195, 87, 66, 125, 104, 3, 22, 41, 60, 255,
        234, 213, 192, 171, 190, 129, 148, 174, 187, 132, 145, 250, 239, 208, 197, 6, 19, 44, 57, 82, 71, 120, 109,
        249, 236, 211, 198, 173, 184, 135, 146, 81, 68, 123, 110, 5, 16, 47, 58, 91, 78, 113, 100, 15, 26, 37, 48, 243,
        230, 217, 204, 167, 178, 141, 152, 12, 25, 38, 51, 88, 77, 114, 103, 164, 177, 142, 155, 240, 229, 218, 207,
        245, 224, 223, 202, 161, 180, 139, 158, 93, 72, 119, 98, 9, 28, 35, 54, 162, 183, 136, 157, 246, 227, 220, 201,
        10, 31, 32, 53, 94, 75, 116, 97, 182, 163, 156, 137, 226, 247, 200, 221, 30, 11, 52, 33, 74, 95, 96, 117, 225,
        244, 203, 222, 181, 160, 159, 138, 73, 92, 99, 118, 29, 8, 55, 34, 24, 13, 50, 39, 76, 89, 102, 115, 176, 165,
        154, 143, 228, 241, 206, 219, 79, 90, 101, 112, 27, 14, 49, 36, 231, 242, 205, 216, 179, 166, 153, 140, 237,
        248, 199, 210, 185, 172, 147, 134, 69, 80, 111, 122, 17, 4, 59, 46, 186, 175, 144, 133, 238, 251, 196, 209, 18,
        7, 56, 45, 70, 83, 108, 121, 67, 86, 105, 124, 23, 2, 61, 40, 235, 254, 193, 212, 191, 170, 149, 128, 20, 1,
        62, 43, 64, 85, 106, 127, 188, 169, 150, 131, 232, 253, 194, 215,
    ];
    const TABLE2: [u32; 256] = [
        0, 107, 214, 189, 171, 192, 125, 22, 81, 58, 135, 236, 250, 145, 44, 71, 162, 201, 116, 31, 9, 98, 223, 180,
        243, 152, 37, 78, 88, 51, 142, 229, 67, 40, 149, 254, 232, 131, 62, 85, 18, 121, 196, 175, 185, 210, 111, 4,
        225, 138, 55, 92, 74, 33, 156, 247, 176, 219, 102, 13, 27, 112, 205, 166, 134, 237, 80, 59, 45, 70, 251, 144,
        215, 188, 1, 106, 124, 23, 170, 193, 36, 79, 242, 153, 143, 228, 89, 50, 117, 30, 163, 200, 222, 181, 8, 99,
        197, 174, 19, 120, 110, 5, 184, 211, 148, 255, 66, 41, 63, 84, 233, 130, 103, 12, 177, 218, 204, 167, 26, 113,
        54, 93, 224, 139, 157, 246, 75, 32, 11, 96, 221, 182, 160, 203, 118, 29, 90, 49, 140, 231, 241, 154, 39, 76,
        169, 194, 127, 20, 2, 105, 212, 191, 248, 147, 46, 69, 83, 56, 133, 238, 72, 35, 158, 245, 227, 136, 53, 94,
        25, 114, 207, 164, 178, 217, 100, 15, 234, 129, 60, 87, 65, 42, 151, 252, 187, 208, 109, 6, 16, 123, 198, 173,
        141, 230, 91, 48, 38, 77, 240, 155, 220, 183, 10, 97, 119, 28, 161, 202, 47, 68, 249, 146, 132, 239, 82, 57,
        126, 21, 168, 195, 213, 190, 3, 104, 206, 165, 24, 115, 101, 14, 179, 216, 159, 244, 73, 34, 52, 95, 226, 137,
        108, 7, 186, 209, 199, 172, 17, 122, 61, 86, 235, 128, 150, 253, 64, 43,
    ];
    const TABLE3: [u32; 256] = [
        0, 22, 44, 58, 88, 78, 116, 98, 176, 166, 156, 138, 232, 254, 196, 210, 103, 113, 75, 93, 63, 41, 19, 5, 215,
        193, 251, 237, 143, 153, 163, 181, 206, 216, 226, 244, 150, 128, 186, 172, 126, 104, 82, 68, 38, 48, 10, 28,
        169, 191, 133, 147, 241, 231, 221, 203, 25, 15, 53, 35, 65, 87, 109, 123, 155, 141, 183, 161, 195, 213, 239,
        249, 43, 61, 7, 17, 115, 101, 95, 73, 252, 234, 208, 198, 164, 178, 136, 158, 76, 90, 96, 118, 20, 2, 56, 46,
        85, 67, 121, 111, 13, 27, 33, 55, 229, 243, 201, 223, 189, 171, 145, 135, 50, 36, 30, 8, 106, 124, 70, 80, 130,
        148, 174, 184, 218, 204, 246, 224, 49, 39, 29, 11, 105, 127, 69, 83, 129, 151, 173, 187, 217, 207, 245, 227,
        86, 64, 122, 108, 14, 24, 34, 52, 230, 240, 202, 220, 190, 168, 146, 132, 255, 233, 211, 197, 167, 177, 139,
        157, 79, 89, 99, 117, 23, 1, 59, 45, 152, 142, 180, 162, 192, 214, 236, 250, 40, 62, 4, 18, 112, 102, 92, 74,
        170, 188, 134, 144, 242, 228, 222, 200, 26, 12, 54, 32, 66, 84, 110, 120, 205, 219, 225, 247, 149, 131, 185,
        175, 125, 107, 81, 71, 37, 51, 9, 31, 100, 114, 72, 94, 60, 42, 16, 6, 212, 194, 248, 238, 140, 154, 160, 182,
        3, 21, 47, 57, 91, 77, 119, 97, 179, 165, 159, 137, 235, 253, 199, 209,
    ];

    let mut crc = seed;
    while buf.len() >= 4 {
        crc ^= u32::from_le_bytes(buf[..4].try_into().unwrap());
        crc = TABLE3[(crc & 0xFF) as usize]
            ^ TABLE2[((crc >> 8) & 0xFF) as usize]
            ^ TABLE1[((crc >> 16) & 0xFF) as usize]
            ^ TABLE0[(crc >> 24) as usize];
        buf = &buf[4..];
    }

    for b in buf {
        crc = (crc >> 8) ^ TABLE0[((crc & 0xff) as u8 ^ *b) as usize];
    }

    crc
}

/// Gets the hash value by CRC-8.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
#[inline]
pub fn hash_crc8(buf: &[u8]) -> u32 {
    hash_crc8_continuous(buf, true, 0)
}

/// Gets the hash value by CRC-16, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 0 for the frist call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_crc16_continuous(buf: &[u8], _finish: bool, seed: u32) -> u32 {
    const TABLE: [u32; 256] = [
        0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657,
        528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314,
        13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907,
        9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628,
        22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285,
        19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814,
        31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407,
        28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256,
        33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721,
        37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570,
        42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971,
        47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628,
        51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093,
        56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814,
        60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215,
        65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920,
    ];

    let mut crc = seed;
    for b in buf {
        crc = TABLE[((crc >> 8) as u8 ^ *b) as usize] ^ (crc << 8);
    }

    crc & 0xffff
}

/// Gets the hash value by CRC-16.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
#[inline]
pub fn hash_crc16(buf: &[u8]) -> u32 {
    hash_crc16_continuous(buf, true, 0)
}

/// Gets the hash value by CRC-32, in a continuous way.
///
/// # Arguments
/// * `buf`: The source buffer.
/// * `finish`: True if the cycle is to be finished.
/// * `seed`: A seed value.  This should be 0xffffffff for the first call of the cycle.
///
/// # Returns
/// The hash value.
pub fn hash_crc32_continuous(mut buf: &[u8], finish: bool, seed: u32) -> u32 {
    const TABLE0: [u32; 256] = [
        0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324,
        3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648,
        2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636,
        335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145,
        1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101,
        3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705,
        3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565,
        1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290,
        251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866,
        2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202,
        4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538,
        1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467,
        855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635,
        3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443,
        3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523,
        3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580,
        2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920,
        282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732,
        1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512,
        3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109,
        3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625,
        752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877,
        83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881,
        2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934,
        4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406,
        1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270,
        936918000, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150,
        3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471,
        3272380065, 1510334235, 755167117,
    ];
    const TABLE1: [u32; 256] = [
        0, 421212481, 842424962, 724390851, 1684849924, 2105013317, 1448781702, 1329698503, 3369699848, 3519200073,
        4210026634, 3824474571, 2897563404, 3048111693, 2659397006, 2274893007, 1254232657, 1406739216, 2029285587,
        1643069842, 783210325, 934667796, 479770071, 92505238, 2182846553, 2600511768, 2955803355, 2838940570,
        3866582365, 4285295644, 3561045983, 3445231262, 2508465314, 2359236067, 2813478432, 3198777185, 4058571174,
        3908292839, 3286139684, 3670389349, 1566420650, 1145479147, 1869335592, 1987116393, 959540142, 539646703,
        185010476, 303839341, 3745920755, 3327985586, 3983561841, 4100678960, 3140154359, 2721170102, 2300350837,
        2416418868, 396344571, 243568058, 631889529, 1018359608, 1945336319, 1793607870, 1103436669, 1490954812,
        4034481925, 3915546180, 3259968903, 3679722694, 2484439553, 2366552896, 2787371139, 3208174018, 950060301,
        565965900, 177645455, 328046286, 1556873225, 1171730760, 1861902987, 2011255754, 3132841300, 2745199637,
        2290958294, 2442530455, 3738671184, 3352078609, 3974232786, 4126854035, 1919080284, 1803150877, 1079293406,
        1498383519, 370020952, 253043481, 607678682, 1025720731, 1711106983, 2095471334, 1472923941, 1322268772,
        26324643, 411738082, 866634785, 717028704, 2904875439, 3024081134, 2668790573, 2248782444, 3376948395,
        3495106026, 4219356713, 3798300520, 792689142, 908347575, 487136116, 68299317, 1263779058, 1380486579,
        2036719216, 1618931505, 3890672638, 4278043327, 3587215740, 3435896893, 2206873338, 2593195963, 2981909624,
        2829542713, 998479947, 580430090, 162921161, 279890824, 1609522511, 1190423566, 1842954189, 1958874764,
        4082766403, 3930137346, 3245109441, 3631694208, 2536953671, 2385372678, 2768287173, 3155920004, 1900120602,
        1750776667, 1131931800, 1517083097, 355290910, 204897887, 656092572, 1040194781, 3113746450, 2692952403,
        2343461520, 2461357009, 3723805974, 3304059991, 4022511508, 4141455061, 2919742697, 3072101800, 2620513899,
        2234183466, 3396041197, 3547351212, 4166851439, 3779471918, 1725839073, 2143618976, 1424512099, 1307796770,
        45282277, 464110244, 813994343, 698327078, 3838160568, 4259225593, 3606301754, 3488152955, 2158586812,
        2578602749, 2996767038, 2877569151, 740041904, 889656817, 506086962, 120682355, 1215357364, 1366020341,
        2051441462, 1667084919, 3422213966, 3538019855, 4190942668, 3772220557, 2945847882, 3062702859, 2644537544,
        2226864521, 52649286, 439905287, 823476164, 672009861, 1733269570, 2119477507, 1434057408, 1281543041,
        2167981343, 2552493150, 3004082077, 2853541596, 3847487515, 4233048410, 3613549209, 3464057816, 1239502615,
        1358593622, 2077699477, 1657543892, 764250643, 882293586, 532408465, 111204816, 1585378284, 1197851309,
        1816695150, 1968414767, 974272232, 587794345, 136598634, 289367339, 2527558116, 2411481253, 2760973158,
        3179948583, 4073438432, 3956313505, 3237863010, 3655790371, 347922877, 229101820, 646611775, 1066513022,
        1892689081, 1774917112, 1122387515, 1543337850, 3697634229, 3313392372, 3998419255, 4148705398, 3087642289,
        2702352368, 2319436851, 2468674930,
    ];
    const TABLE2: [u32; 256] = [
        0, 29518391, 59036782, 38190681, 118073564, 114017003, 76381362, 89069189, 236147128, 265370511, 228034006,
        206958561, 152762724, 148411219, 178138378, 190596925, 472294256, 501532999, 530741022, 509615401, 456068012,
        451764635, 413917122, 426358261, 305525448, 334993663, 296822438, 275991697, 356276756, 352202787, 381193850,
        393929805, 944588512, 965684439, 1003065998, 973863097, 1061482044, 1049003019, 1019230802, 1023561829,
        912136024, 933002607, 903529270, 874031361, 827834244, 815125939, 852716522, 856752605, 611050896, 631869351,
        669987326, 640506825, 593644876, 580921211, 551983394, 556069653, 712553512, 733666847, 704405574, 675154545,
        762387700, 749958851, 787859610, 792175277, 1889177024, 1901651959, 1931368878, 1927033753, 2006131996,
        1985040171, 1947726194, 1976933189, 2122964088, 2135668303, 2098006038, 2093965857, 2038461604, 2017599123,
        2047123658, 2076625661, 1824272048, 1836991623, 1866005214, 1861914857, 1807058540, 1786244187, 1748062722,
        1777547317, 1655668488, 1668093247, 1630251878, 1625932113, 1705433044, 1684323811, 1713505210, 1742760333,
        1222101792, 1226154263, 1263738702, 1251046777, 1339974652, 1310460363, 1281013650, 1301863845, 1187289752,
        1191637167, 1161842422, 1149379777, 1103966788, 1074747507, 1112139306, 1133218845, 1425107024, 1429406311,
        1467333694, 1454888457, 1408811148, 1379576507, 1350309090, 1371438805, 1524775400, 1528845279, 1499917702,
        1487177649, 1575719220, 1546255107, 1584350554, 1605185389, 3778354048, 3774312887, 3803303918, 3816007129,
        3862737756, 3892238699, 3854067506, 3833203973, 4012263992, 4007927823, 3970080342, 3982554209, 3895452388,
        3924658387, 3953866378, 3932773565, 4245928176, 4241609415, 4271336606, 4283762345, 4196012076, 4225268251,
        4187931714, 4166823541, 4076923208, 4072833919, 4035198246, 4047918865, 4094247316, 4123732899, 4153251322,
        4132437965, 3648544096, 3636082519, 3673983246, 3678331705, 3732010428, 3753090955, 3723829714, 3694611429,
        3614117080, 3601426159, 3572488374, 3576541825, 3496125444, 3516976691, 3555094634, 3525581405, 3311336976,
        3298595879, 3336186494, 3340255305, 3260503756, 3281337595, 3251864226, 3222399125, 3410866088, 3398419871,
        3368647622, 3372945905, 3427010420, 3448139075, 3485520666, 3456284973, 2444203584, 2423127159, 2452308526,
        2481530905, 2527477404, 2539934891, 2502093554, 2497740997, 2679949304, 2659102159, 2620920726, 2650438049,
        2562027300, 2574714131, 2603727690, 2599670141, 2374579504, 2353749767, 2383274334, 2412743529, 2323684844,
        2336421851, 2298759554, 2294686645, 2207933576, 2186809023, 2149495014, 2178734801, 2224278612, 2236720739,
        2266437690, 2262135309, 2850214048, 2820717207, 2858812622, 2879680249, 2934667388, 2938704459, 2909776914,
        2897069605, 2817622296, 2788420399, 2759153014, 2780249921, 2700618180, 2704950259, 2742877610, 2730399645,
        3049550800, 3020298727, 3057690558, 3078802825, 2999835404, 3004150075, 2974355298, 2961925461, 3151438440,
        3121956959, 3092510214, 3113327665, 3168701108, 3172786307, 3210370778, 3197646061,
    ];
    const TABLE3: [u32; 256] = [
        0, 3099354981, 2852767883, 313896942, 2405603159, 937357362, 627793884, 2648127673, 3316918511, 2097696650,
        1874714724, 3607201537, 1255587768, 4067088605, 3772741427, 1482887254, 1343838111, 3903140090, 4195393300,
        1118632049, 3749429448, 1741137837, 1970407491, 3452858150, 2511175536, 756094997, 1067759611, 2266550430,
        449832999, 2725482306, 2965774508, 142231497, 2687676222, 412010587, 171665333, 2995192016, 793786473,
        2548850444, 2237264098, 1038456711, 1703315409, 3711623348, 3482275674, 1999841343, 3940814982, 1381529571,
        1089329165, 4166106984, 4029413537, 1217896388, 1512189994, 3802027855, 2135519222, 3354724499, 3577784189,
        1845280792, 899665998, 2367928107, 2677414085, 657096608, 3137160985, 37822588, 284462994, 2823350519,
        2601801789, 598228824, 824021174, 2309093331, 343330666, 2898962447, 3195996129, 113467524, 1587572946,
        3860600759, 4104763481, 1276501820, 3519211397, 1769898208, 2076913422, 3279374443, 3406630818, 1941006535,
        1627703081, 3652755532, 1148164341, 4241751952, 3999682686, 1457141531, 247015245, 3053797416, 2763059142,
        470583459, 2178658330, 963106687, 735213713, 2473467892, 992409347, 2207944806, 2435792776, 697522413,
        3024379988, 217581361, 508405983, 2800865210, 4271038444, 1177467017, 1419450215, 3962007554, 1911572667,
        3377213406, 3690561584, 1665525589, 1799331996, 3548628985, 3241568279, 2039091058, 3831314379, 1558270126,
        1314193216, 4142438437, 2928380019, 372764438, 75645176, 3158189981, 568925988, 2572515393, 2346768303,
        861712586, 3982079547, 1441124702, 1196457648, 4293663189, 1648042348, 3666298377, 3358779879, 1888390786,
        686661332, 2421291441, 2196002399, 978858298, 2811169155, 523464422, 226935048, 3040519789, 3175145892,
        100435649, 390670639, 2952089162, 841119475, 2325614998, 2553003640, 546822429, 2029308235, 3225988654,
        3539796416, 1782671013, 4153826844, 1328167289, 1570739863, 3844338162, 1298864389, 4124540512, 3882013070,
        1608431339, 3255406162, 2058742071, 1744848601, 3501990332, 2296328682, 811816591, 584513889, 2590678532,
        129869501, 3204563416, 2914283062, 352848211, 494030490, 2781751807, 3078325777, 264757620, 2450577869,
        715964072, 941166918, 2158327331, 3636881013, 1618608400, 1926213374, 3396585883, 1470427426, 4011365959,
        4255988137, 1158766284, 1984818694, 3471935843, 3695453837, 1693991400, 4180638033, 1100160564, 1395044826,
        3952793279, 3019491049, 189112716, 435162722, 2706139399, 1016811966, 2217162459, 2526189877, 774831696,
        643086745, 2666061564, 2354934034, 887166583, 2838900430, 294275499, 54519365, 3145957664, 3823145334,
        1532818963, 1240029693, 4048895640, 1820460577, 3560857924, 3331051178, 2117577167, 3598663992, 1858283101,
        2088143283, 3301633750, 1495127663, 3785470218, 4078182116, 1269332353, 332098007, 2876706482, 3116540252,
        25085497, 2628386432, 605395429, 916469259, 2384220526, 2254837415, 1054503362, 745528876, 2496903497,
        151290352, 2981684885, 2735556987, 464596510, 1137851976, 4218313005, 3923506883, 1365741990, 3434129695,
        1946996346, 1723425172, 3724871409,
    ];

    let mut crc = seed;
    while buf.len() >= 4 {
        crc ^= u32::from_le_bytes(buf[..4].try_into().unwrap());
        crc = TABLE3[(crc & 0xFF) as usize]
            ^ TABLE2[((crc >> 8) & 0xFF) as usize]
            ^ TABLE1[((crc >> 16) & 0xFF) as usize]
            ^ TABLE0[(crc >> 24) as usize];
        buf = &buf[4..];
    }

    for b in buf {
        crc = (crc >> 8) ^ TABLE0[((crc & 0xFF) as u8 ^ *b) as usize];
    }

    if finish {
        crc ^= 0xFFFFFFFF;
    }

    crc
}

/// Gets the hash value by CRC-32.
///
/// # Arguments
/// * `buf`: The source buffer.
///
/// # Returns
/// The hash value.
#[inline]
pub fn hash_crc32(buf: &[u8]) -> u32 {
    hash_crc32_continuous(buf, true, 0xffffffff)
}

#[cfg(test)]
mod tests {
    use {
        super::{
            hash_adler16, hash_adler16_continuous, hash_adler32, hash_adler32_continuous, hash_adler6,
            hash_adler6_continuous, hash_adler8, hash_adler8_continuous, hash_checksum6, hash_checksum6_continuous,
            hash_checksum6_pair, hash_checksum8, hash_checksum8_continuous, hash_checksum8_pair, hash_crc16,
            hash_crc16_continuous, hash_crc32, hash_crc32_continuous, hash_crc4, hash_crc4_continuous, hash_crc8,
            hash_crc8_continuous, hash_fnv, hash_murmur,
        },
        pretty_assertions::assert_eq,
    };

    fn make_cyclic_string(size: usize) -> Vec<u8> {
        let mut result = Vec::with_capacity(size);
        for i in 0..size {
            result.push(i as u8);
        }

        result
    }

    #[test]
    fn test_hash_murmur() {
        assert_eq!(hash_murmur(b"Hello World", 19780211), 0x15941D6097FA1378);
        assert_eq!(hash_murmur("こんにちは世界".as_bytes(), 19780211), 0x4C6A0FFD2F090C3A);
        assert_eq!(hash_murmur(&make_cyclic_string(256), 19780211), 0xD247B93561BD1053);
        assert_eq!(hash_murmur(&make_cyclic_string(100000), 19780211), 0x7D20AA9F76F60EC0);
    }

    #[test]
    fn test_hash_fnv() {
        assert_eq!(0x9AA143013F1E405F, hash_fnv(b"Hello World"));
        assert_eq!(0x8609C402DAD8A1EF, hash_fnv("こんにちは世界".as_bytes()));
        assert_eq!(0x2F8C4ED90D46DE25, hash_fnv(&make_cyclic_string(256)));
        assert_eq!(0xB117046EFB9CE805, hash_fnv(&make_cyclic_string(100000)));
    }

    #[test]
    fn test_hash_checksum6() {
        assert_eq!(0x2C, hash_checksum6(b"hello"));
        assert_eq!(0x0F, hash_checksum6(b"Hello World"));
        assert_eq!(0x04, hash_checksum6("こんにちは世界".as_bytes()));
        assert_eq!(0x05, hash_checksum6(&make_cyclic_string(256)));
        assert_eq!(0x1E, hash_checksum6(&make_cyclic_string(100000)));
        let crc = hash_checksum6_continuous(b"Hello", false, 0);
        let crc = hash_checksum6_continuous(b" ", false, crc);
        let crc = hash_checksum6_continuous(b"World", true, crc);
        assert_eq!(0x0F, crc);
        let crc = hash_checksum6_continuous("こんにちは".as_bytes(), false, 0);
        let crc = hash_checksum6_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0x04, crc);
        assert_eq!(0x0F, hash_checksum6_pair(b"Hello", b" World", 0));
        assert_eq!(0x04, hash_checksum6_pair("こんにちは".as_bytes(), "世界".as_bytes(), 0));
        for i in 0..256 {
            let key = &make_cyclic_string(i);
            assert!(hash_checksum6(key) < 61);
        }
    }

    #[test]
    fn test_hash_checksum8() {
        assert_eq!(0x1E, hash_checksum8(b"hello"));
        assert_eq!(0x30, hash_checksum8(b"Hello World"));
        assert_eq!(0x96, hash_checksum8("こんにちは世界".as_bytes()));
        assert_eq!(0x0A, hash_checksum8(&make_cyclic_string(256)));
        assert_eq!(0x36, hash_checksum8(&make_cyclic_string(100000)));
        let crc = hash_checksum8_continuous(b"Hello", false, 0);
        let crc = hash_checksum8_continuous(b" ", false, crc);
        let crc = hash_checksum8_continuous(b"World", true, crc);
        assert_eq!(0x30, crc);
        let crc = hash_checksum8_continuous("こんにちは".as_bytes(), false, 0);
        let crc = hash_checksum8_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0x96, crc);
        assert_eq!(0x30, hash_checksum8_pair(b"Hello", b" World", 0));
        assert_eq!(0x96, hash_checksum8_pair("こんにちは".as_bytes(), "世界".as_bytes(), 0));
        for i in 0..256 {
            let key = &make_cyclic_string(i);
            assert!(hash_checksum8(key) < 251);
        }
    }

    #[test]
    fn test_hash_adler6() {
        assert_eq!(0x29, hash_adler6(b"hello"));
        assert_eq!(0x13, hash_adler6(b"Hello World"));
        assert_eq!(0x14, hash_adler6("こんにちは世界".as_bytes()));
        assert_eq!(0x00, hash_adler6(&make_cyclic_string(256)));
        assert_eq!(0x34, hash_adler6(&make_cyclic_string(100000)));
        let crc = hash_adler6_continuous(b"Hello", false, 1);
        let crc = hash_adler6_continuous(b" ", false, crc);
        let crc = hash_adler6_continuous(b"World", true, crc);
        assert_eq!(0x13, crc);
        let crc = hash_adler6_continuous("こんにちは".as_bytes(), false, 1);
        let crc = hash_adler6_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0x14, crc);
        for i in 0..256 {
            let key = &make_cyclic_string(i);
            assert!(hash_adler6(key) < 64);
        }
    }

    #[test]
    fn test_hash_adler8() {
        assert_eq!(0x70, hash_adler8(b"hello"));
        assert_eq!(0x60, hash_adler8(b"Hello World"));
        assert_eq!(0x2C, hash_adler8("こんにちは世界".as_bytes()));
        assert_eq!(0xCB, hash_adler8(&make_cyclic_string(256)));
        assert_eq!(0x17, hash_adler8(&make_cyclic_string(100000)));
        let crc = hash_adler8_continuous(b"Hello", false, 1);
        let crc = hash_adler8_continuous(b" ", false, crc);
        let crc = hash_adler8_continuous(b"World", true, crc);
        assert_eq!(0x60, crc);
        let crc = hash_adler8_continuous("こんにちは".as_bytes(), false, 1);
        let crc = hash_adler8_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0x2C, crc);
        for i in 0..256 {
            let key = &make_cyclic_string(i);
            assert!(hash_adler8(key) < 256);
        }
    }

    #[test]
    fn test_hash_adler16() {
        assert_eq!(0x4A1F, hash_adler16(b"hello"));
        assert_eq!(0x8331, hash_adler16(b"Hello World"));
        assert_eq!(0x9B97, hash_adler16("こんにちは世界".as_bytes()));
        assert_eq!(0x190B, hash_adler16(&make_cyclic_string(256)));
        assert_eq!(0xC337, hash_adler16(&make_cyclic_string(100000)));
        let crc = hash_adler16_continuous(b"Hello", false, 1);
        let crc = hash_adler16_continuous(b" ", false, crc);
        let crc = hash_adler16_continuous(b"World", true, crc);
        assert_eq!(0x8331, crc);
        let crc = hash_adler16_continuous("こんにちは".as_bytes(), false, 1);
        let crc = hash_adler16_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0x9B97, crc);
        for i in 0..256 {
            let key = &make_cyclic_string(i);
            assert!(hash_adler16(key) < 65536);
        }
    }

    #[test]
    fn test_hash_adler32() {
        assert_eq!(0x062C0215, hash_adler32(b"hello"));
        assert_eq!(0x180B041D, hash_adler32(b"Hello World"));
        assert_eq!(0x9D7B0E51, hash_adler32("こんにちは世界".as_bytes()));
        assert_eq!(0xADF67F81, hash_adler32(&make_cyclic_string(256)));
        assert_eq!(0x61657A0F, hash_adler32(&make_cyclic_string(100000)));
        let crc = hash_adler32_continuous(b"Hello", false, 1);
        let crc = hash_adler32_continuous(b" ", false, crc);
        let crc = hash_adler32_continuous(b"World", true, crc);
        assert_eq!(0x180B041D, crc);
        let crc = hash_adler32_continuous("こんにちは".as_bytes(), false, 1);
        let crc = hash_adler32_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0x9D7B0E51, crc);
    }

    #[test]
    fn test_hash_crc4() {
        assert_eq!(0xD, hash_crc4(b"hello"));
        assert_eq!(0x9, hash_crc4(b"Hello World"));
        assert_eq!(0xE, hash_crc4("こんにちは世界".as_bytes()));
        assert_eq!(0x5, hash_crc4(&make_cyclic_string(256)));
        assert_eq!(0x3, hash_crc4(&make_cyclic_string(100000)));
        let crc = hash_crc4_continuous(b"Hello", false, 0);
        let crc = hash_crc4_continuous(b" ", false, crc);
        let crc = hash_crc4_continuous(b"World", true, crc);
        assert_eq!(0x9, crc);
        let crc = hash_crc4_continuous("こんにちは".as_bytes(), false, 0);
        let crc = hash_crc4_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0xE, crc);
        for i in 0..256 {
            let key = &make_cyclic_string(i);
            assert!(hash_crc4(key) < 16);
        }
    }

    #[test]
    fn test_hash_crc8() {
        assert_eq!(0x92, hash_crc8(b"hello"));
        assert_eq!(0x25, hash_crc8(b"Hello World"));
        assert_eq!(0xB7, hash_crc8("こんにちは世界".as_bytes()));
        assert_eq!(0x14, hash_crc8(&make_cyclic_string(256)));
        assert_eq!(0xB8, hash_crc8(&make_cyclic_string(100000)));
        let crc = hash_crc8_continuous(b"Hello", false, 0);
        let crc = hash_crc8_continuous(b" ", false, crc);
        let crc = hash_crc8_continuous(b"World", true, crc);
        assert_eq!(0x25, crc);
        let crc = hash_crc8_continuous("こんにちは".as_bytes(), false, 0);
        let crc = hash_crc8_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0xB7, crc);
        for i in 0..256 {
            let key = &make_cyclic_string(i);
            assert!(hash_crc8(key) < 256);
        }
    }

    #[test]
    fn test_hash_crc16() {
        assert_eq!(0xC362, hash_crc16(b"hello"));
        assert_eq!(0x992A, hash_crc16(b"Hello World"));
        assert_eq!(0xF802, hash_crc16("こんにちは世界".as_bytes()));
        assert_eq!(0x7E55, hash_crc16(&make_cyclic_string(256)));
        assert_eq!(0x96E2, hash_crc16(&make_cyclic_string(100000)));
        let crc = hash_crc16_continuous(b"Hello", false, 0);
        let crc = hash_crc16_continuous(b" ", false, crc);
        let crc = hash_crc16_continuous(b"World", true, crc);
        assert_eq!(0x992A, crc);
        let crc = hash_crc16_continuous("こんにちは".as_bytes(), false, 0);
        let crc = hash_crc16_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0xF802, crc);
        for i in 0..256 {
            let key = &make_cyclic_string(i);
            assert!(hash_crc16(key) < 65536);
        }
    }

    #[test]
    fn test_hash_crc32() {
        assert_eq!(0x3610A686, hash_crc32(b"hello"));
        assert_eq!(0x4A17B156, hash_crc32(b"Hello World"));
        assert_eq!(0x75197186, hash_crc32("こんにちは世界".as_bytes()));
        assert_eq!(0x29058C73, hash_crc32(&make_cyclic_string(256)));
        assert_eq!(0xAACF4FC9, hash_crc32(&make_cyclic_string(100000)));
        let crc = hash_crc32_continuous(b"Hello", false, 0xffffffff);
        let crc = hash_crc32_continuous(b" ", false, crc);
        let crc = hash_crc32_continuous(b"World", true, crc);
        assert_eq!(0x4A17B156, crc);
        let crc = hash_crc32_continuous("こんにちは".as_bytes(), false, 0xffffffff);
        let crc = hash_crc32_continuous("世界".as_bytes(), true, crc);
        assert_eq!(0x75197186, crc);
    }
}
